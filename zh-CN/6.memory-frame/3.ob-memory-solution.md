# 6.2 OceanBase 中内存安全问题解决方案

C++ 程序世界里开发者可以直接操控内存，享受极致性能的同时也催生了无穷无尽的内存安全漏洞，每个漏洞都有可能让服务器崩溃并且需要测试开发人员投入大量的时间和精力。功能不断迭代的背景下漏洞是很难避免的，如何快速发现这些漏洞并精准定位，是个很大的议题。

最常用方法有 mprotect 和 Address Sanity（Asan)。mprotect 方案有很大的限制，一方面它要求地址是 OS page 对齐的，另一方面长度也必须是 page size 的整数倍，这样就无法保护小字节内存。而 Asan 方案相对而言比较通用，Asan 依靠编译插桩技术实现了运行期检查可以发现各种各样的安全漏洞，哪怕很小的内存越界都可以检查到。

OceanBase 也依靠 Asan 发现了很多关键 bug。但随着压测环境逐渐丰富与壮大，Asan 则不再适用，原因在于它的性能表现不佳。高并发服务器程序对测试压力的要求很高，Asan 不能很好地保证性能测试质量。

Asan 性能不佳的主要原因如下：

- Malloc 函数多核性能太差，有单点瓶颈。

- 支持栈内存与全局变量的检查，overhead 高。

- 为了极致的易用性，malloc/free 堆栈全纪录，backtrace 性能差。

基于以上原因，OceanBase 自研了一套 Sanity 框架，设计思路与 Asan 比较相似，但是因为 Sanity 框架的 Malloc 函数是我们自己实现的，所以多核性能扩展性较好，不会再有单点瓶颈问题。

接下来介绍一下 Sanity 框架是怎么实现的。首先它也是依靠编译技术实现，即编译阶段修改 OceanBase 数据库的代码，在所有访存指令之前插入检查函数。这个函数会检查目标地址是否可以访问，不可以访问则直接 abort，让程序崩溃，这样就可以把第一现场保留下来。

为了快速判定地址是否可访问，OceanBase 定义了 Shadow 内存，所有分配的内存都会有相应的元信息内存，这个元信息记录了源内存是否可访问。为了高效，元信息地址与跟原始内存地址是 8 倍关系，即原始地址右移三位就是元信息地址，这么设计的好处是可以快速索引。另外它们的地址是隔离的，所以不存在用户数据写坏元信息的问题，既满足了高效要求，也满足了隔离性需求。

Shadow 内存是核心元数据，它保存了访问权限，每 8 字节的 canonical 都由 1 字节的 Shadow 描述，当前实现下 Shadow 字节的含义如下：

- 0x0 代表相应 8 字节全部可访问。

- 0xf0 代表相应 8 字节全部不可访问。

- 0x${n} 表示 8 字节里前 n 个字节可访问，后 8-n 个字节不可访问。

Shadow 地址可由 canonical 地址直接计算得到，将索引开销降到了最低，当前实现下的换算关系为 shadow_addr = canonical_addr >> 3。

另外 Sanity 框架有一些优化，一个是通过设置隔离区延迟内存的复用，大幅提高 use-after-free 漏洞的检查概率。另一个是记录调用链，调用链对于排查 use-after-free 问题很有用。
