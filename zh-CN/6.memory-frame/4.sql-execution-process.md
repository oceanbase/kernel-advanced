# 6.3 SQL 执行过程

本节介绍一条 SQL 请求执行的完整过程，主要是偏向线程角度，分三个方面。

- 线程分类：即有哪些限制以及各自的职责是什么；

- 数据流转：即数据在线程之间的流转关系是怎样的；

- SQL 执行：SQL 的执行过程。

## 线程分类

线程细分有很多种，总体上可以分两大类：

- 工作线程

  直接去执行 SQL 任务的线程，有时候也会叫做前台线程。

- 系统线程

  系统线程也叫后台线程。系统线程里面有一部分是专门用来响应这客户端请求的，即专门处理网络请求的，它跟 SQL 执行请求直接相关。除了网络线程以外还有一些其他后台线程，比如执行调度转储等任务。

## 数据流转

一个完整的请求处理过程是客户端发送请求给 OBServer，由网络线程接收请求，网络线程会进一步解码将请求发送到租户的任务队列，由租户的工作线程消费，工作线程处理结束后唤醒网络线程给客户端发送响应。

![01](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/6.memory-frame/4.sql-execution-process-01.png)

这里有两点需要注意一下：

- 全局均衡原则

  - 除了 IO 线程是多队列的，前台工作线程都是全局队列。

  - 不同 SQL 执行时间变化很大，为了 RT 更平稳，只能使用全局队列。

- 避免阻塞

  - 相比 MySQL 或 Oracle，OceanBase 的一个特点是可以支持很大的连接数，这就造成线程数往往远小于连接数，所以事务执行阶段会尽可能异步避免阻塞。例如行锁冲突，OceanBase 的做法是直接回滚事务，然后等待重试。

  - 事务提交方面的优化，比如事务结束需要响应客户端，这个过程会丢给一组事务线程异步处理，提早解放工作线程，虽然单个请求的 RT 没有变化，但可以得到更大地吞吐，这也是一个很大的优化。

  - 事务、日志、选举等内部模块都是全异步模型，几乎没有同步 RPC。

## SQL 的执行过程

首先应用通过客户端将请求发送给 OBServer，OBServer 由网络线程接收请求进行解码，进而发送到相应租户的工作队列，由一组工作线程负责处理。SQL 流程里的处理逻辑如下图里右边虚线框中的部分，这部分内容比较复杂，这里简单介绍一下，各个模块的详细介绍请参见 [SQL 层整体架构](https://www.oceanbase.com/docs/community-developer-quickstart-0000000000717679)。

![02](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/6.memory-frame/4.sql-execution-process-02.png)

如上图所示，SQL 首先会经过 Parser 模块，就是纯语法的解析，之后经过 Resolver 模块，Resolver 相比 Parser 会带有一些语义信息，然后经过 Transformer 模块，这里会做一些基本的规则优化，再将处理的结果给到 Optimizer 模块，Optimizer 会有一些基于代价模型的深度优化，最终产生最佳的逻辑执行计划，后面的 Code Generator 相当于是一个编译过程，它将逻辑执行计划转化成物理执行计划进而流入执行引擎。

这些流程并不一定会全部走完，因为比较耗费资源，所以会有一个 Plan Cache 模块对物理计划进行缓存，从而让相同 SQL 的解析更快。SQL 执行完成后结果会经过网络线程反馈给客户端，整个流程就结束了。
