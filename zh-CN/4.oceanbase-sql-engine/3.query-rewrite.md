# 4.2 查询改写

## 为什么要改写

首先通过一个例子说明为什么要做查询改写。

```sql
UPDATE T 
SET    status = 'DONE' 
WHERE  T.id IN (SELECT id
                FROM   T
                WHERE  T.type=10
                ORDER  BY k
                LIMIT  3) 
```

如上所示，这条 SQL 是某个业务的真实 SQL，这里把表名列名做了一下简化，其中 `id` 是表的主键。可以看出这条 SQL 对 T 表做了一个更新操作，更新的行满足 id 列的值在一个子查询的结果中。而子查询查出了 T 表中 `type=10`，并且按照 K 列排序的前三行的 id。

这条 SQL 对于用户来说，可能是一个“好”的 SQL，因为这样写非常的直观，很好的描述了需要更新哪些值。但对于数据库来说，这样的 SQL 不算是一个“好”的 SQL，因为这一个 UPDATE 语句中出现了多个表，还有子查询，如果完全不做改写直接用这条 SQL 生成计划，会让计划生成更加复杂。

仔细观察这条 SQL 可以看出，这里用户想要做的就是更新 T 表中 `type=10`，并且按照 K 列排序的前三行。

因此经过一系列的改写，上述 SQL 会被改写成如下形式。

```sql
UPDATE T
SET status = 'DONE'
WHERE T.type = 10
ORDER BY k
LIMIT 3
```

该 SQL 只涉及到单表，并且没有子查询，计划生成更加容易，对数据库来说是一条“好”的 SQL。因此改写的目的就是为了把用户输入的 SQL 改写成更易于优化的形式。

> **说明**
>
> 这里说的易于优化，其实包含多层的含义。直观的来说，消除掉一个连接表、消除掉无效的过滤条件都可以让 SQL 变得更易于优化，这个是很容易理解的，表、条件都没了也就不用优化了。

从另一方面讲，如果改写可以让优化器能够考虑更多的连接算法，比如改写前只能使用 Nest Loop Join，改写后还可以额外使用 Hash Join 或 Merge Join，此时也认为这让 SQL 变得更易于优化，因为可选的计划更多了，也就更有可能选到更好的计划。

## 查询改写的挑战

查询改写模块是 OceanBase 优化器投入最多的一个模块，这是因为查询改写是一个非常难的事情，其中最难的点主要有两个。

* 正确性问题

  即无论怎样改写，都要保证改写后的 SQL 和改写前的 SQL 的语意是等价的。

* 完备性问题

  前面也有提到，SQL 这种描述性语言想要查出一个特定的结果是有很多种不同的写法的，完备性要求不论使用哪种方式写 SQL，数据库都要识别出来去做改写。

更进一步来说。查询改写本质上是一个模式匹配的过程，在匹配的过程中要保证改写的完整性。这里通过一个例子进行说明。

```sql
SELECT *  FROM T1  WHERE  T1.PK > 0
                   AND  T1.C1 < 10
                   AND  1 = 1;
```

上述 SQL 中有三个过滤条件：

* T1.PK > 0

* T1.C1 < 10

* 1=1

其中 `1=1` 其实是一个恒真的条件，实际上在去优化的时候完全不需要考虑这个条件（因为它永远是真），所以就可以直接把它删掉。这时就会有一个改写，把这个恒真的过滤条件给删掉，就会如下图一样，把图中上方的 statement 改写成下方的 statement 形式。

![改写](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/4.oceanbase-sql-engine/3.query-rewrite-01.png)

完备性就要求除了考虑 WHERE 中的这种恒真条件之外，还要考虑这个恒真条件可能会出现在其他地方。比如说可能会出现在 on 里面，也可能会出现在 having 里面。所以说无论这个恒真条件出现在哪里，都要去把它识别出来，然后把它消除掉。

正确性就是要保证改写做的是一个等价的变化。这里也就是说要求改写前后的 SQL 在语意上是等价的。一旦语意不等价，比如本来用户写了一个 order by，结果改写过程中把这个 order by 消除了，那么结果的语意就发生了变化，就可能产生正确性问题。

## 有效性判断

在进行改写时还需要做查询改写的有效性判断，也就是判断要不要做这个改写。在 OceanBase 中改写分成两大类，一类是基于规则的，一类是基于代价的。而这两类改写的有效性判断是有所区别的。

### 基于规则的改写

基于规则的改写总是把 SQL 往好的方向改写，也就是说如果是基于规则改写，那就一定会去做这个改写。结合下面的示例进行说明：

```sql
SELECT * 
FROM t1    
WHERE t1.c2 IN (SELECT t2.c2
                FROM   t2 
                WHERE  t1.c3 = t2.c3) 
```

这里有条 SQL，该 SQL 的过滤条件是 t1.c2 IN 一个子查询。该子查询是一个相关子查询，因为该子查询的结果又依赖于 t1.c3 这一列的值。如果不做改写，那么它的计划就如下图。

![执行计划图1](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/4.oceanbase-sql-engine/3.query-rewrite-02.png)

首先会查出 t1 表所有的数据，之后对于 t1 表中的每一行，会用 SUBPLAN FILTER 这个算子去驱动做这个子查询。之后把 t1.c3 的值带入到这个子查询中查出所有满足条件的 t2.c2 的值，然后去判断一下 t1.c2 是不是在这个子查询的结果中。如果在，就把它返回。

学过一些数据库原理的同学应该会知道，这个执行方式非常类似于 Nest Loop Join，对于驱动表的每一行，都要去扫描被驱动表的数据。假设这里 t1 有十万行，就要反复的去扫描 t2 表十万次，这个性能其实是非常差的。

如果这里做一个改写，比如把这条 SQL 改写成一个 SEMI JOIN 的形式。这种情况之下，我们可以用 Nest Loop Join，也可以用 Merge Join 和 Hash Join，这就有了更多的选择。如果在 t2 表没有索引的场景下，其实选择 Hash Join 是一个非常好的一个计划。

![执行计划图2](https://obbusiness-private.oss-cn-shanghai.aliyuncs.com/doc/img/kernel-advanced/V1.0.0/zh-CN/4.oceanbase-sql-engine/3.query-rewrite-03.png)

### 基于代价的改写

基于代价的改写需要计算代价之后才能决定是否把 SQL 往好的方向改。

这里依然结合一个例子进行说明：

```sql
SELECT * 
FROM t1    
WHERE t1.a1 = 1 or t1.b1 = 1; 
```

从上述 SQL 可以看出，用户尝试去查出 t1 表上所有 `a1=1` 或者是 `b1=1` 的 SQL，那么这条 SQL 应该如何优化呢？这里有一个思路，是否可以先查出 t1 中所有 `a1=1` 的数据，再查出所有 `b1=1` 的数据，之后把这两个结果合在一起？

基于这个想法，上述 SQL 可以改写成如下形式：

```sql
SELECT * 
FROM t1    
WHERE t1.a1 = 1
UNION ALL
SELECT *
FROM T1
WHERE t1.b1 = 1 and lnnvl(t1.a1 = 1); 
```

SQL 中多了一个 UNION ALL 语句， UNION ALL 的上方查出了所有 `t1.a1=1` 的数据。UNION ALL 的下方查出了所有 `t1.b1=1` 的数据。但是这里有一个问题，当  `t1.a1=1` 且 `t1.b1=1` 时，按照上面的逻辑，数据会被查出来两次，因此这里就多了一个条件 `lnnvl(t1.a1 = 1)`，保证数据只会被返回一次。

但其实往往无法确定如此改写是否是往“好”的方向改，需要根据具体的情况进行分析。

* 如果 t1 的 a1 和 b1 上都有一个索引，那么这个改写会把 SQL 往一个“好”的方向去改写的。因为 UNION ALL 上方这条 SQL 可以利用 a1 上的索引来快速的定位数据。UNION ALL 下方的这条 SQL 可以利用 b1 上的索引快速定位数据。这种情况下，改写后的 SQL 就比改写前的 SQL 要好。

* 如果 t1 的 a1 和 b1 上都没有一个索引。这时这个改写并不能让 SQL 往“好”的方向改写。因为对于改写前的 SQL 来说，只要把 t1 表扫描一遍，就能拿到所有需要的数据。而对于改写后的 SQL，需要把 t1 表扫描两次才能拿到所需要的数据，执行代价一定是比扫描一遍要高的。

所以这种改写叫做基于代价改写，会分别估算一下改写前 SQL 的代价是多少，改写后的 SQL 代价是多少。只有当发现改写后的代价比改写前低时，才会选择去改写。

这种改写当然会比基于规则的改写稍微难一些，因为需要计算代价后才能确定要不要做改写。这要求在改写的过程中要保留两份 statement，一份是改写前的，一份是改写后的。一旦计算代价后发现改写后的 SQL 代价更高，就要把 SQL 回退到改写前。同时计算代价需要走一遍查询优化的流程，这就导致基于代价改写的 overhead 比基于规则的改写大很多（不论是时间还是空间都要大）。而且完全基于代价也未必是准确的，因为当 SQL 中出现多表连接或者复杂的谓词时，优化器的选择率计算和代价计算是没有那么准确的，这个问题是所有的数据库优化器都存在的问题。

所以在代价改写中我们也加入了一些规则的判断，会判断改写后计划的形状，当计划形状满足要求时也会强制去做改写。

OceanBase 的改写框架在改写过程中会不断迭代基于规则的改写和基于代价的改写，这个迭代是同时进行的，不会说先去迭代基于规则的改写直到改写不了了再去迭代基于代价。因为这样会错失很多改写的机会。所以改写框架会选择同时迭代基于规则的和基于代价的改写，按照自定义的改写顺序去做改写，直到改写收敛或者迭代 10 轮。

### 改写规则

目前 OceanBase 中已经支持了很多的规则，这里列出了一部分。可以说基本上学术界和工业界那些广为人知的改写 OceanBase 都支持了。除了这些以外还有很多独有的改写规则，这些改写规则是我们的开发人员根据实际使用场景抽象提炼出来的。

* 基于规则的改写规则

  * 恒正、恒假条件简化

  * 常量折叠

  * SPJ 和非 SPJ 的视图合并

  * 连接消除

  * 非聚合类子查询提升

  * 外连接消除

  * 聚合类子查询提升

  * 谓词推导

  * Limit-k 下压

  * Group by/window func/Distinct/Order by 消除

* 基于代价的改写规则

  * Or-expansion

  * Group by replacement

  * 窗口函数改写

  * Semi to Inner 改写

  * 子查询合并

上述列举出的改写规则这里不一一介绍了，感兴趣的同学可以看一下开源社区正在更新的改写系列文章：<https://open.oceanbase.com/blog/10900257>。这个系列的文章会介绍不同改写的作用、好处，对有 SQL 基础并想了解查询改写细节的同学很有帮助。
